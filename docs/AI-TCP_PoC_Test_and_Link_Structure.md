AI-TCP PoC Test and Link Structure
English Version

日本語版

English Version
1. Overall PoC Test Structure
The AI-TCP Proof of Concept (PoC) revolves around a physically verifiable, end-to-end workflow.

1.1. Core Test Flow
Standby: The CLI, via task_bridge_runner.py, actively monitors the cli_instruction/ directory for new_task.json.

Execution: Upon detecting the file, the CLI executes the commands listed in the JSON sequentially.

Verification: The final command in the JSON sequence is always create_flag, which generates ./validate_files/complete.flag.

Archiving: Upon successful flag generation, the new_task.json and its corresponding logs are timestamped and moved to the cli_archives/ directory. The success of the entire test is determined by the physical existence of the complete.flag.

1.2. PoC for Codex-Generated Scripts
Purpose: To validate Codex's role as an autonomous toolsmith.

Method: A task within new_task.json will explicitly call a Python script that was previously generated by Codex and committed to the repository (e.g., python pytools/validate_structured_yaml.py ...).

Success Condition: The successful execution of this script as part of the overall flow (confirmed by the complete.flag) serves as the PoC for this capability.

1.3. Phased LLM Integration Testing
Testing of LLM interactions is conducted in stages to isolate variables.

Phase 1: Local LLM (LM Studio):

Objective: Validate core interaction logic and data parsing without network latency or API costs.

Procedure: Scripts are configured to target the local LM Studio server endpoint. This stage focuses on ensuring the prompts and expected responses are structurally sound.

Phase 2: Remote LLM (API):

Objective: Validate the end-to-end workflow with the production Gemini/GPT APIs.

Procedure: Once the logic is confirmed locally, scripts are switched to use the official remote API endpoints. This stage tests for real-world performance, error handling, and API compliance.

2. Document Link Structure (link_map.json)
To maintain conceptual integrity and ease of navigation within a tool like Obsidian, link_map.json serves as the master index. It defines the relationships and reference points between key documents.

2.1. Minimal link_map.json Structure
{
  "root": {
    "entry_point": "docs/README.md",
    "description": "Overall project overview and entry point for all agents."
  },
  "governance": {
    "inheritance_guide": {
      "path": "docs/AI-TCP_Inheritance_Guide.md",
      "description": "The canonical source of truth for project philosophy, roles, and core principles. Referenced to resolve any cognitive dissonance."
    },
    "github_guide": {
      "path": "docs/GitHub_Operation_Guide.md",
      "description": "Defines branching, PR, and approval rules. Referenced during any code contribution or merge."
    }
  },
  "workflow": {
    "flag_workflow": {
      "path": "docs/AI-TCP_FlagWorkflow.md",
      "description": "Technical specification of the task execution and completion flag mechanism. Referenced for debugging CLI operations."
    },
    "test_structure": {
      "path": "docs/AI-TCP_Test_Structure.md",
      "description": "Defines the multi-layered testing strategy. Referenced when designing or executing any test case."
    }
  }
}

2.2. Symbolic Linking in Practice (Obsidian Context)
docs/AI-TCP_Inheritance_Guide.md: This is the core node. All other documents should symbolically link back to this guide as the ultimate reference for the "why." For instance, the GitHub_Operation_Guide.md would reference it to explain why human approval for Codex scripts is a mandatory principle.

docs/GitHub_Operation_Guide.md: This document is referenced whenever a developer (human or AI) prepares to commit code or create a pull request. It's the "how-to" for repository management.

docs/AI-TCP_FlagWorkflow.md: This is the primary technical reference for understanding the core execution loop. It should be linked from the AI-TCP_Test_Structure.md and the README.md's section on CLI testing.

This structure creates a navigable knowledge graph, ensuring that any agent can traverse from the high-level philosophy (Inheritance_Guide) down to the specific implementation details (FlagWorkflow) in a logical, consistent manner.

日本語版
1. PoCテスト構造の全体像
AI-TCPの概念実証（PoC）は、物理的に検証可能なエンドツーエンドのワークフローを中心に展開されます。

1.1. コアテストフロー
待機: CLIは、task_bridge_runner.pyを介して、cli_instruction/ディレクトリをアクティブに監視し、new_task.jsonを待ち受けます。

実行: ファイルを検知すると、CLIはJSONにリストされたコマンドを順次実行します。

検証: JSONシーケンスの最後のコマンドは常にcreate_flagであり、これにより./validate_files/complete.flagが生成されます。

アーカイブ: フラグが正常に生成されると、new_task.jsonとそれに対応するログにはタイムスタンプが付与され、cli_archives/ディレクトリに移動されます。テスト全体の成功は、complete.flagの物理的な存在によって判断されます。

1.2. Codex生成スクリプトのPoC
目的: 自律的なツール職人としてのCodexの役割を検証すること。

方法: new_task.json内のタスクが、以前にCodexによって生成されリポジトリにコミットされたPythonスクリプト（例: python pytools/validate_structured_yaml.py ...）を明示的に呼び出します。

成功条件: 全体フローの一部としてこのスクリプトが正常に実行されること（complete.flagによって確認）が、この能力のPoCとなります。

1.3. 段階的なLLM統合テスト
LLMとの対話テストは、変数を分離するために段階的に実施されます。

フェーズ1: ローカルLLM (LM Studio):

目的: ネットワーク遅延やAPIコストなしで、コアとなる対話ロジックとデータ解析を検証する。

手順: スクリプトをローカルのLM Studioサーバーエンドポイントをターゲットとするように設定します。この段階では、プロンプトと期待される応答が構造的に健全であることを確認することに焦点を当てます。

フェーズ2: リモートLLM (API):

目的: 本番のGemini/GPT APIを使用して、エンドツーエンドのワークフローを検証する。

手順: ロジックがローカルで確認された後、スクリプトを公式のリモートAPIエンドポイントを使用するように切り替えます。この段階では、実環境でのパフォーマンス、エラーハンドリング、APIコンプライアンスをテストします。

2. ドキュメントリンク構造 (link_map.json)
Obsidianのようなツール内での概念的な整合性とナビゲーションの容易さを維持するため、link_map.jsonはマスターインデックスとして機能します。これは、主要なドキュメント間の関係性と参照点を定義します。

2.1. link_map.jsonの最小構造
{
  "root": {
    "entry_point": "docs/README.md",
    "description": "プロジェクト全体の概要であり、全エージェントのエントリーポイント。"
  },
  "governance": {
    "inheritance_guide": {
      "path": "docs/AI-TCP_Inheritance_Guide.md",
      "description": "プロジェクト哲学、役割、基本原則に関する正典。認知的不協和を解決するために参照される。"
    },
    "github_guide": {
      "path": "docs/GitHub_Operation_Guide.md",
      "description": "ブランチ、PR、承認ルールを定義。コードのコントリビューションやマージの際に参照される。"
    }
  },
  "workflow": {
    "flag_workflow": {
      "path": "docs/AI-TCP_FlagWorkflow.md",
      "description": "タスク実行と完了フラグメカニズムの技術仕様。CLI操作のデバッグ時に参照される。"
    },
    "test_structure": {
      "path": "docs/AI-TCP_Test_Structure.md",
      "description": "多層的なテスト戦略を定義。テストケースの設計または実行時に参照される。"
    }
  }
}

2.2. 実践におけるシンボリックリンク（Obsidianの文脈）
docs/AI-TCP_Inheritance_Guide.md: これがコアノードです。他のすべてのドキュメントは、「なぜ」を説明する究極の参照元として、このガイドにシンボリックリンクされるべきです。例えば、GitHub_Operation_Guide.mdは、Codexスクリプトに対する人間の承認が必須原則である理由を説明するためにこれを参照します。

docs/GitHub_Operation_Guide.md: このドキュメントは、開発者（人間またはAI）がコードをコミットしたりプルリクエストを作成したりする準備をする際に参照されます。リポジトリ管理の「ハウツー」です。

docs/AI-TCP_FlagWorkflow.md: これは、コア実行ループを理解するための主要な技術参照です。AI-TCP_Test_Structure.mdやREADME.mdのCLIテストに関するセクションからリンクされるべきです。

この構造は、ナビゲーション可能な知識グラフを形成し、どのエージェントも高レベルの哲学（Inheritance_Guide）から具体的な実装詳細（FlagWorkflow）まで、論理的で一貫した方法でたどれるようにします。